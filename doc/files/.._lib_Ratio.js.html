<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>..\lib\Ratio.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.3.6</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Ratio.html">Ratio</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ..\lib\Ratio.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * @project Ratio.js
 * @purpose Provides a Ratio(Fraction) object for Javascript. Similar to Fraction.py for Python.
 * @author Larry Battle , &lt;http:&#x2F;&#x2F;bateru.com&#x2F;news&#x2F;&gt;
 * @license MIT and GPL 3.0
MIT License &lt;http:&#x2F;&#x2F;www.opensource.org&#x2F;licenses&#x2F;mit-license&gt;
GPL v3 &lt;http:&#x2F;&#x2F;opensource.org&#x2F;licenses&#x2F;GPL-3.0&gt;
 * @info Project page: &lt;https:&#x2F;&#x2F;github.com&#x2F;LarryBattle&#x2F;Ratio.js&#x2F;&gt;
 * @version 0.3.6
 * @note Uses YUI-DOC to generate documentation.
 **&#x2F;
var Ratio = (function () {
    &quot;use strict&quot;;
    &#x2F;**
     * Ratio is an object that has a numerator and denominator, corresponding to a&#x2F;b.&lt;br&#x2F;&gt;
     * Note that the keyword &#x60;new&#x60; is not required to create a new instance of the Ratio object, since this is done for you.&lt;br&#x2F;&gt;
     * In otherwords, &#x60;new Ratio( value )&#x60; is the same as &#x60;Ratio( value )&#x60;.
     *
     * @class Ratio
     * @constructor
     * @chainable
     * @param {Ratio|String|Number} [numerator=0] can be a Ratio object or numeric value.
     * @param {Ratio|String|Number} [denominator=1] can be a Ratio object or numeric value.
     * @param {Boolean} [alwaysReduce] if true, then the Ratio object and the child of it will always represent the simplified form of the rational.
     * @return {Ratio} object that has a numerator and denominator, corresponding to a&#x2F;b.
     * @example
    Ratio(2,4).toString() == Ratio(&quot;2&#x2F;4&quot;).toString() == &quot;2&#x2F;4&quot;
     **&#x2F;
    var Ratio = function (numerator, denominator, alwaysReduce) {
        if (!(this instanceof Ratio)) {
            return new Ratio(numerator, denominator, alwaysReduce);
        }
        this.divSign = &quot;&#x2F;&quot;;
        this.alwaysReduce = !!alwaysReduce;
        this.denominator = denominator;
        this.numerator = numerator;
        return this.correctRatio();
    };
    Ratio.regex = {
        divSignCheck : &#x2F;(\d|Infinity)\s*\&#x2F;&#x2F;,
        divSignSplit : &#x2F;\&#x2F;&#x2F;,
        cleanFormat : &#x2F;^\d+\.\d+$&#x2F;,
        mixedNumbers : &#x2F;(\S+)\s+(\S[\w\W]*)&#x2F;,
        repeatingDecimals : &#x2F;(?:[^\.]+\.\d*)(\d{2,})+(?:\1)$&#x2F;,
        repeatingNumbers : &#x2F;^(\d+)(?:\1)$&#x2F;
    };
    &#x2F;**
     * Version number of Ratio.js
     * @property Ratio.VERSION
     * @type String
     **&#x2F;
    Ratio.VERSION = &quot;0.3.6&quot;;
    &#x2F;**
     * Checks if value is a finite number. &lt;br&#x2F;&gt; Borrowed from jQuery 1.7.2 &lt;br&#x2F;&gt;
     *
     * @method Ratio.isNumeric
     * @param {Object} obj
     * @return {Boolean}
     * @example
    Ratio.isNumeric(&quot;1.0e3&quot;) == true
     **&#x2F;
    Ratio.isNumeric = function (obj) {
        return !isNaN(parseFloat(obj)) &amp;&amp; isFinite(obj);
    };
    &#x2F;**
     * Returns the default value is the provides new value is undefined or null.&lt;br&#x2F;&gt;
     * Similar to &#x60;var a = (b || c)&#x60;.
     *
     * @method Ratio.getValueIfDefined
     * @param {Object} backup
     * @param {Object} value
     * @return {Object}
     * @example
    Ratio.getValueIfDefined( 4, null ) == 4
     **&#x2F;
    Ratio.getValueIfDefined = function (backup, value) {
        return typeof value !== &quot;undefined&quot; &amp;&amp; value !== null ? value : backup;
    };
    &#x2F;**
     * Find the Greatest Common Factor between two numbers using &quot;Euler Method&quot;.
     *
     * @method Ratio.gcd
     * @param {Number} a
     * @return {Number} b
     * @example
    Ratio.gcd(20,12) == 4
     **&#x2F;
    Ratio.gcd = function (a, b) {
        var c;
        b = (+b &amp;&amp; +a) ? +b : 0;
        a = b ? a : 1;
        while (b) {
            c = a % b;
            a = b;
            b = c;
        }
        return Math.abs(a);
    };
    &#x2F;**
     * Returns the numerator with the corresponding sign of (top&#x2F;bottom).&lt;br&#x2F;&gt;
     * Used to force &#x60;top&#x60; to represent the sign of the Ratio.
     *
     * @method Ratio.getNumeratorWithSign
     * @param {Number} top
     * @param {Number} bottom
     * @return {Number}
     * @example
    Ratio.getNumeratorWithSign(1,-2) == -1
     **&#x2F;
    Ratio.getNumeratorWithSign = function (top, bottom) {
        var sign = (+top * (+bottom || 1)) &lt; 0 ? -1 : 1;
        return Math.abs(+top) * sign;
    };
    &#x2F;**
     * Provides a quick way to find out the numeric type of an object.
     * Types include: &#x60;NaN&#x60;, &#x60;Ratio&#x60;, &#x60;number&#x60;, &#x60;e&#x60;, &#x60;decimal&#x60;, &#x60;mixed&#x60; and &#x60;fraction&#x60;
     *
     * @method Ratio.getTypeGuess
     * @param {Object} obj
     * @return {String} type
     * @example
    Ratio.getTypeGuess(&quot;1&#x2F;3&quot;) == &quot;fraction&quot;;
     **&#x2F;
    Ratio.getTypeGuess = function (obj) {
        var type = &quot;NaN&quot;;
        if (obj instanceof Ratio) {
            type = &quot;Ratio&quot;;
        } else if (!isNaN(obj)) {
            type = &quot;number&quot;;
            if (&#x2F;e&#x2F;i.test(+obj)) {
                type = &quot;e&quot;;
            } else if (obj % 1) {
                type = &quot;decimal&quot;;
            }
        } else if (Ratio.regex.divSignCheck.test(obj)) {
            if (&#x2F;\d\s+[+\-]?\d&#x2F;.test(obj)) {
                type = &quot;mixed&quot;;
            } else {
                type = &quot;fraction&quot;;
            }
        }
        return type;
    };
    &#x2F;**
     * Converts a numeric value to a Ratio in the form of [top, bottom], such that top&#x2F;bottom.
     *
     * @method Ratio.parseToArray
     * @param {Number|String} obj Numeric Object.
     * @return {Array[Number, Number]}
     * @example
    Ratio.parseToArray( 0.125 ) &#x2F;&#x2F; returns [125, 1000]
     **&#x2F;
    Ratio.parseToArray = function (obj) {
        var parts = [],
        j,
        arr = [],
        top;
        switch (Ratio.getTypeGuess(obj)) {
        case &quot;mixed&quot;:
            parts = obj.match(Ratio.regex.mixedNumbers);
            arr = Ratio.parseToArray(parts[2]);
            j = 0 &lt; (parseFloat(parts[1]) * arr[0]) ? 1 : -1;
            arr[0] = j * (Math.abs(arr[0]) + Math.abs(parts[1] * arr[1]));
            break;
        case &quot;fraction&quot;:
            parts = obj.split(Ratio.regex.divSignSplit);
            arr[0] = Ratio.getNumeratorWithSign(parts[0], parts[1]);
            arr[1] = Math.abs(+parts[1]);
            break;
        case &quot;decimal&quot;:
            parts = (+obj).toString().split(&#x2F;\.&#x2F;);
            arr[1] = Math.pow(10, parts[1].length);
            arr[0] = Math.abs(parts[0]) * arr[1] + (+parts[1]);
            arr[0] = (&#x2F;\-&#x2F;.test(parts[0])) ? -arr[0] : arr[0];
            break;
        case &quot;number&quot;:
            arr = [+obj, 1];
            break;
        case &quot;e&quot;:
            parts = (+obj).toString().split(&#x2F;e&#x2F;i);
            top = Ratio.parseToArray(parts[0]);
            j = (Math.abs(+obj) &lt; 1) ? [0, 1] : [1, 0];
            arr[j[0]] = top[j[0]];
            arr[j[1]] = Number(top[j[1]] + &quot;e&quot; + Math.abs(+parts[1]));
            break;
        case &quot;Ratio&quot;:
            arr = [obj.numerator, obj.denominator];
            break;
        default:
            arr = [NaN, 1];
        }
        return arr;
    };
    &#x2F;**
     * Converts a numeric value to a Ratio object.
     * Supports mixed numbers, whole numbers, decimals, scientific numbers and Ratio objects.
     *
     * @method Ratio.parse
     * @chainable
     * @param {Ratio|Number|String} obj - numerator
     * @param {Ratio|Number|String} [obj] - denominator
     * @return {Ratio}
     * @example
    &#x2F;&#x2F;whole numbers &lt;br&#x2F;&gt;
    Ratio.parse(22,7).toString() == &quot;22&#x2F;7&quot;;
    
    &#x2F;&#x2F; mixed numbers &lt;br&#x2F;&gt;
    Ratio.parse(&quot;3 1&#x2F;7&quot;).toString() == &quot;22&#x2F;7&quot;;
    
    &#x2F;&#x2F; decimals &lt;br&#x2F;&gt;
    Ratio.parse(22&#x2F;7).reduce().toLocaleString() == &quot;3 1&#x2F;7&quot;;
    
    &#x2F;&#x2F; fractions &lt;br&#x2F;&gt;
    Ratio.parse(&quot;22&#x2F;7&quot;).toLocaleString() == &quot;3 1&#x2F;7&quot;;
    
    &#x2F;&#x2F; scientific notated numbers &lt;br&#x2F;&gt;
    Ratio.parse(&quot;22e31&#x2F;70e30&quot;).reduce().toLocaleString() == &quot;3 1&#x2F;7&quot;;
     **&#x2F;
    Ratio.parse = function (obj, obj2) {
        var arr = Ratio.parseToArray(obj),
        arr2;
        if (arr.length &amp;&amp; obj2 !== undefined &amp;&amp; obj2 !== null) {
            arr2 = Ratio.parseToArray(obj2);
            arr[0] *= arr2[1];
            arr[1] *= arr2[0];
        }
        return new Ratio(arr[0], arr[1]);
    };
    &#x2F;**
     * Given a numerator and denominator in the form of [a,b], returns as an array of numbers.
     *
     * @method Ratio.reduce
     * @param {Ratio|Number|String} obj
     * @param {Ratio|Number|String} [obj]
     * @return {Array[ Number, Number ]}
     * @example
    Example 1:&lt;br&#x2F;&gt;
    Ratio.reduce( Ratio(36,-36) ) &#x2F;&#x2F; returns [-1,1]
    
    Example 2:&lt;br&#x2F;&gt;
    Ratio.reduce( &quot;9&#x2F;12&quot; ) &#x2F;&#x2F; returns [3,4]
    
    Example 3:&lt;br&#x2F;&gt;
    Ratio.reduce( &quot;10&#x2F;4&quot; ).toString() &#x2F;&#x2F; returns [5,2]
     **&#x2F;
    Ratio.reduce = function (obj, obj2) {
        obj = Ratio.parse(obj, obj2);
        var top = obj.numerator,
        bottom = top ? obj.denominator : 1,
        arr = Ratio.getRepeatProps(top &#x2F; bottom),
        factor;
        if (arr.length) {
            top = Number(arr.join(&#x27;&#x27;)) - Number(arr[0] + String(arr[1]));
            bottom = Math.pow(10, arr[1].length) * (Math.pow(10, arr[2].length) - 1);
        }
        factor = Ratio.gcd(top, bottom);
        return [top &#x2F; factor, bottom &#x2F; factor];
    };
    &#x2F;**
     * This function divides a repeating decimal into 3 parts. If the value passed is not a repeating decimal then an empty array is returned.&lt;br&#x2F;&gt;
     * For repeating decimals, the return value is an array which contains the numeric value split into 3 parts like, &lt;br&#x2F;&gt;
     * [ &quot;numbers before decimal&quot;, &quot;numbers before repeating pattern&quot;, &quot;repeating pattern.&quot; ].&lt;br&#x2F;&gt;
     * Here&#x27;s another explanation. &lt;br&#x2F;&gt;
     * The return value is [i, x, r] for the repeating decimal value.&lt;br&#x2F;&gt;
     * where i are the values to the left of the decimal point. &lt;br&#x2F;&gt;
     * x are the decimals to the right of the decimal point and to the left of the repeating pattern.&lt;br&#x2F;&gt;
     * r is the unique repeating patterns for the repeating decimal.&lt;br&#x2F;&gt;
     * Example. 22&#x2F;7 = 3.142857142857143 = 3.14-285714-285714-3, i = 3, x = 14, r = 285714&lt;br&#x2F;&gt;
     * It should be noted that the last digit might be removed to avoid rounding errors.
     *
     * @method Ratio.getRepeatProps
     * @param {Number} val
     * @return {Array} an array of 3 numbers.
     * @example
    Ratio.getRepeatProps( 22&#x2F;7 ) &#x2F;&#x2F; returns [&quot;3&quot;, &quot;14&quot;, &quot;285714&quot;]
     **&#x2F;
    Ratio.getRepeatProps = function (val) {
        val = String(val || &quot;&quot;);
        var RE1_getRepeatDecimals = Ratio.regex.repeatingDecimals,
        arr = [],
        match = RE1_getRepeatDecimals.exec(val),
        RE2_RE1AtEnd,
        RE3_RepeatingNums = Ratio.regex.repeatingNumbers;
        if (!match) {
            val = val.replace(&#x2F;\d$&#x2F;, &quot;&quot;);
            match = RE1_getRepeatDecimals.exec(val);
        }
        if (match &amp;&amp; 1 &lt; match.length &amp;&amp; &#x2F;\.\d{10}&#x2F;.test(match[0])) {
            match[1] = RE3_RepeatingNums.test(match[1]) ? RE3_RepeatingNums.exec(match[1])[1] : match[1];
            RE2_RE1AtEnd = new RegExp(&quot;(&quot; + match[1] + &quot;)+$&quot;);
            arr = val.split(&#x2F;\.&#x2F;).concat(match[1]);
            arr[1] = arr[1].replace(RE2_RE1AtEnd, &quot;&quot;);
        }
        return arr;
    };
    &#x2F;**
     * Returns an array of the prime factors of a number. &lt;br&#x2F;&gt;
     * More info &lt;http:&#x2F;&#x2F;bateru.com&#x2F;news&#x2F;2012&#x2F;05&#x2F;code-of-the-day-javascript-prime-factors-of-a-number&#x2F;&gt;
     *
     * @method Ratio.getPrimeFactors
     * @param {Number} num
     * @return {Array} an array of numbers
     * @example
    Ratio.getPrimeFactors(20) &#x2F;&#x2F; returns [2,2,5]
     **&#x2F;
    Ratio.getPrimeFactors = function (num) {
        num = Math.floor(num);
        var root,
        factors = [],
        x,
        sqrt = Math.sqrt,
        doLoop = 1 &lt; num &amp;&amp; isFinite(num);
        while (doLoop) {
            root = sqrt(num);
            x = 2;
            if (num % x) {
                x = 3;
                while ((num % x) &amp;&amp; ((x += 2) &lt; root)) {}
            }
            x = (root &lt; x) ? num : x;
            factors.push(x);
            doLoop = (x !== num);
            num &#x2F;= x;
        }
        return factors;
    };
    &#x2F;**
     * Rounds up a scientific notated number with 8+ trailing 0s or 9s.&lt;br&#x2F;&gt;
     * Note: Returns number as string to preserve value.
     *
     * @method Ratio.getCleanENotation
     * @param {Number} num
     * @return {String}
     * @example
    Example 1&lt;br&#x2F;&gt;
    Ratio.getCleanENotation( &quot;1.1000000000000003e-30&quot; ) === &quot;1.1e-30&quot;;
    
    Example 2&lt;br&#x2F;&gt;
    Ratio.getCleanENotation( &quot;9.999999999999999e+22&quot; ) === &quot;1e+23&quot;;
     **&#x2F;
    Ratio.getCleanENotation = function (num) {
        num = (+num || 0).toString();
        if (&#x2F;\.\d+(0|9){8,}\d?e&#x2F;.test(num)) {
            var i = num.match(&#x2F;(?:\d+\.)(\d+)(?:e[\w\W]*)&#x2F;)[1].replace(&#x2F;(0|9)+\d$&#x2F;, &#x27;&#x27;).length + 1;
            num = (+num).toPrecision(i).toString();
        }
        return num;
    };
    &#x2F;**
     * Used to combine two ratios into one.
     *
     * @method Ratio.getCombinedRatio
     * @chainable
     * @return {Ratio}
     * @example
    Ratio.getCombinedRatio(&quot;1&#x2F;2&quot;,&quot;1&#x2F;3&quot;).toString() == &quot;3&#x2F;2&quot;
     **&#x2F;
    Ratio.getCombinedRatio = function (obj, obj2) {
        if (!(obj instanceof Ratio) || obj2 !== undefined) {
            obj = Ratio.parse(obj, obj2);
        }
        return obj;
    };
    Ratio.prototype = {
        constructor : Ratio,
        &#x2F;**
         * Adjusts the ratio in three ways:
         *
         * 1) Sets the numerator and denominator to default values if undefined. (Default fraction: 0&#x2F;1)
         * 2) Places the sign on numerator.
         * 3) Reduces the function if needed.
         * This function is called after the instances is created.
         *
         * @method Ratio.prototype.correctRatio
         * @param {Object} obj
         * @return {Ratio}
         * @example
        Ratio().toString(); &#x2F;&#x2F; &#x60;.correctRatio()&#x60; was called internally.
         **&#x2F;
        correctRatio : function () {
            var a = this.numerator,
            b = this.denominator,
            arr;
            if (typeof b === &quot;undefined&quot;) {
                b = 1;
                if (typeof a === &quot;undefined&quot;) {
                    a = 0;
                }
            }
            this.denominator = +Math.abs(b);
            this.numerator = Ratio.getNumeratorWithSign(a, (b || 1));
            if (this.denominator &amp;&amp; this.alwaysReduce) {
                arr = Ratio.reduce(this);
                this.numerator = arr[0];
                this.denominator = arr[1];
            }
            return this;
        },
        
        &#x2F;**
         * From the Ratio instance, returns the raw values of the numerator and denominator in the form [numerator, denominator].
         *
         * @method Ratio.prototype.toArray
         * @return {Array} an array of 2 numbers.
         * @example
        Ratio(1,2).toArray() &#x2F;&#x2F; returns [1,2]
         **&#x2F;
        toArray : function () {
            return [this.numerator, this.denominator];
        },
        &#x2F;**
         * From the Ratio instance, returns the result of the numerator divided by the denominator.
         *
         * @method Ratio.prototype.valueOf
         * @return {Number}
         * @example
        Example 1:&lt;br&#x2F;&gt;
        Ratio(1,2).valueOf() == 0.5;
         **&#x2F;
        valueOf : function () {
            return this.numerator &#x2F; this.denominator;
        },
        &#x2F;**
         * From the Ratio instance, returns a string of the Ratio in fraction form if the numerator and denominator are Rational numbers.&lt;br&#x2F;&gt;
         * Note: If the computed value of (numerator &#x2F; denominator) is a whole number, then the whole number is returned.&lt;br&#x2F;&gt;
         * Note: If the computed value of (numerator &#x2F; denominator) is not a number, the result is returned. &lt;br&#x2F;&gt;
         *
         * @method Ratio.prototype.toLocaleString
         * @return {String}
         * @example
        Example 1:&lt;br&#x2F;&gt;
        Ratio(1,10).toLocaleString() == &quot;1&#x2F;10&quot;
        
        Example 2:&lt;br&#x2F;&gt;
        Ratio(0,0).toLocaleString() == &quot;NaN&quot;
         **&#x2F;
        toLocaleString : function () {
            var val = this.valueOf(),
            x,
            str,
            errorSize = 1e-9;
            if (isNaN(val)) {
                str = &quot;NaN&quot;;
            } else if (val % 1 === 0 || this.denominator === 1 || !isFinite(val % 1)) {
                str = String(val);
            } else if (1 &lt; Math.abs(val)) {
                if (Math.abs(val - val.toFixed(0)) &lt; errorSize) {
                    str = val.toFixed(0);
                } else {
                    x = parseInt(val, 10);
                    str = x + &quot; &quot; + Math.abs(this.numerator % this.denominator) + this.divSign + this.denominator;
                }
            } else {
                str = String(this.numerator + this.divSign + this.denominator);
            }
            return str;
        },
        &#x2F;**
         * From the Ratio instance, returns the raw values of the numerator and denominator in the form &quot;a&#x2F;b&quot;.&lt;br&#x2F;&gt;
         * Note: The division symbol can be change by modification of the &#x60;divSign&#x60; property.
         *
         * @method Ratio.prototype.toString
         * @return {String}
         * @example
        Example 1:&lt;br&#x2F;&gt;
        Ratio(8,2).toString() == &quot;8&#x2F;2&quot;;
        
        Example 2:&lt;br&#x2F;&gt;
        var a = Ratio(8,2);&lt;br&#x2F;&gt;
        a.divSign = &quot;:&quot;;&lt;br&#x2F;&gt;
        a.toString() == &quot;8:2&quot;;
         **&#x2F;
        toString : function () {
            return String(this.numerator + this.divSign + this.denominator);
        },
        &#x2F;**
         * Returns a new instance of the current Ratio.&lt;br&#x2F;&gt;
         * The clone propery value can be changed if the appropriate argument value is supplied.
         *
         * @method Ratio.prototype.clone
         * @param {Number} [top]
         * @param {Number} [bottom]
         * @param {Boolean} [alwaysReduce]
         * @return {Ratio}
         * @example
        var a = Ratio(2,4); &lt;br&#x2F;&gt;
        var b = a.clone(); &lt;br&#x2F;&gt;
        a.equals(b) === true;
         **&#x2F;
        clone : function (top, bottom, alwaysReduce) {
            var func = Ratio.getValueIfDefined;
            top = func(this.numerator, top);
            bottom = func(this.denominator, bottom);
            alwaysReduce = func(this.alwaysReduce, alwaysReduce);
            return new Ratio(top, bottom, alwaysReduce);
        },
        &#x2F;**
         * From the Ratio instance, returns a new instacne with a reduced ratio by factoring out the greatest common multiple.
         *
         * @method Ratio.prototype.reduce
         * @chainable
         * @return {Ratio}
         * @example
        Ratio(10,2).reduce().toString() == &quot;5&#x2F;1&quot;
         **&#x2F;
        reduce : function () {
            var arr = Ratio.reduce(this.numerator, this.denominator);
            return this.clone(arr[0], arr[1]);
        },
        &#x2F;**
         * Adds the current Ratio by another Ratio.
         *
         * @method Ratio.prototype.add
         * @chainable
         * @param {Ratio|Number|String} obj
         * @param {Ratio|Number|String} [obj2]
         * @return {Ratio}
         * @example
        Ratio( 1, 3 ).add( 1,2 ).toString() == &quot;5&#x2F;6&quot;
         **&#x2F;
        add : function (obj, obj2) {
            obj = Ratio.getCombinedRatio(obj, obj2);
            var x,
            top,
            bottom;
            if (this.denominator === obj.denominator) {
                top = this.numerator + obj.numerator;
                bottom = this.denominator;
            } else {
                x = Ratio.gcd(this.denominator, obj.denominator);
                top = ((this.numerator * obj.denominator) + (this.denominator * obj.numerator)) &#x2F; x;
                bottom = (this.denominator * obj.denominator) &#x2F; x;
            }
            return this.clone(top, bottom);
        },
        &#x2F;**
         * Divides the current Ratio by another Ratio.
         *
         * @method Ratio.prototype.divide
         * @chainable
         * @param {Ratio|Number|String} obj
         * @param {Ratio|Number|String} [obj2]
         * @return {Ratio}
         * @example
        Ratio( 1,2 ).divide( 3,4 ).toString() == &quot;2&#x2F;3&quot;
         **&#x2F;
        divide : function (obj, obj2) {
            obj = Ratio.getCombinedRatio(obj, obj2);
            return this.clone(this.numerator * obj.denominator, this.denominator * obj.numerator);
        },
        &#x2F;**
         * Compares if the current Ratio and another object have the same value.
         *
         * @method Ratio.prototype.equals
         * @param {Object} obj
         * @return {Boolean}
         * @example
        Ratio(1,2).equals( 1&#x2F;2 ) === true
         **&#x2F;
        equals : function (obj) {
            var val = (Ratio.isNumeric(obj) || obj instanceof Ratio) ? obj.valueOf() : Ratio.parse(obj).valueOf();
            return (this.numerator &#x2F; this.denominator) === +val;
        },
        &#x2F;**
         * Performs a strict comparison to determine if the current instances and passed object are identical.
         *
         * @method Ratio.prototype.deepEquals
         * @param {Object} obj
         * @return {Boolean}
         * @example
        Ratio(1,2).deepEquals( 1&#x2F;2 ) === false
         *&#x2F;
        deepEquals : function (obj) {
            return (obj instanceof Ratio) &amp;&amp; (this.numerator === obj.numerator) &amp;&amp; (this.denominator === obj.denominator);
        },
        &#x2F;**
         * Multiply the current Ratio by another Ratio.
         *
         * @chainable
         * @method Ratio.prototype.multiply
         * @param {Ratio|Number|String} obj
         * @param {Ratio|Number|String} [obj2]
         * @return {Ratio}
         * @example
        Ratio(2,5).multiply( 1, 2 ).toString() == &quot;2&#x2F;10&quot;
         **&#x2F;
        multiply : function (obj, obj2) {
            obj = Ratio.getCombinedRatio(obj, obj2);
            return this.clone(this.numerator * obj.numerator, this.denominator * obj.denominator);
        },
        &#x2F;**
         * Subtracts the current Ratio by another Ratio.
         *
         * @method Ratio.prototype.subtract
         * @chainable
         * @param {Ratio|Number|String} obj
         * @param {Ratio|Number|String} [obj2]
         * @return {Ratio}
         * @example
        Ratio(2,3).subtract(1,7).toString() === &quot;-1&#x2F;3&quot;
         **&#x2F;
        subtract : function (obj, obj2) {
            obj = Ratio.getCombinedRatio(obj, obj2);
            obj.numerator = -obj.numerator;
            return this.add(obj);
        },
        &#x2F;**
         * From the Ratio instance, returns an new Ratio scaled down by a factor.
         *
         * @method Ratio.prototype.descale
         * @chainable
         * @param {Ratio|Number|String} obj
         * @param {Ratio|Number|String} [obj2]
         * @return {Ratio}
         * @example
        Ratio(10,4).descale( 2 ).toString() === &quot;5&#x2F;2&quot;
         **&#x2F;
        descale : function (obj, obj2) {
            var factor = Ratio.getCombinedRatio(obj, obj2);
            return this.clone(this.numerator &#x2F; factor, this.denominator &#x2F; factor);
        },
        &#x2F;**
         * From the Ratio instance, returns an new Ratio raised to a power.
         *
         * @method Ratio.prototype.pow
         * @chainable
         * @param {Ratio|Number|String} obj
         * @param {Ratio|Number|String} [obj2]
         * @return {Ratio}
         * @example
        Ratio(2,4).pow(4).toString() === &quot;16&#x2F;256&quot;
         **&#x2F;
        pow : function (obj, obj2) {
            var power = Ratio.getCombinedRatio(obj, obj2);
            return this.clone(Math.pow(this.numerator, +power), Math.pow(this.denominator, +power));
        },
        &#x2F;**
         * From the Ratio instance, returns a new Ratio scaled up by a factor.
         *
         * @method Ratio.prototype.scale
         * @chainable
         * @param {Ratio|Number|String} obj
         * @param {Ratio|Number|String} [obj2]
         * @return {Ratio}
         * @example
        Ratio(1,10).scale(10).toString() === &quot;10&#x2F;100&quot;
         **&#x2F;
        scale : function (obj, obj2) {
            var factor = Ratio.getCombinedRatio(obj, obj2);
            return this.clone(this.numerator * +factor, this.denominator * +factor);
        },
        &#x2F;**
         * From the Ratio instance, returns a new Ratio by parsing the numerator and denominator.&lt;br&#x2F;&gt;
         * This is useful if want to ensure that the Ratio contains only whole numbers in the numerator and denominator after a caclulation.
         *
         * @method Ratio.prototype.cleanFormat
         * @chainable
         * @return {Ratio}
         * @example
        var a = Ratio(20,30).descale(3); &lt;br&#x2F;&gt;
        a.toString() == &quot;6.666666666666667&#x2F;10&quot;; &lt;br&#x2F;&gt;
        a.cleanFormat().toString() == &quot;6666666666666667&#x2F;10000000000000000&quot;
         **&#x2F;
        cleanFormat : function () {
            var re = Ratio.regex.cleanFormat,
            obj;
            if (re.test(this.numerator) || re.test(this.denominator)) {
                return Ratio.parse(this.numerator, this.denominator);
            }
            obj = this.clone();
            obj.numerator = Ratio.getCleanENotation(obj.numerator);
            obj.denominator = Ratio.getCleanENotation(obj.denominator);
            return obj;
        },
        &#x2F;**
         * Returns a new instances that is the absolute value of the current Ratio.
         *
         * @method Ratio.prototype.abs
         * @chainable
         * @return {Ratio}
         * @example
        Ratio(-3,2).abs().toString() == &quot;3&#x2F;2&quot;
         **&#x2F;
        abs : function () {
            return this.clone(Math.abs(this.numerator));
        },
        &#x2F;**
         * From the Ratio instance, returns a new Ratio in the form of (numerator mod denominator)&#x2F;1.&lt;br&#x2F;&gt;
         * Which is the same as Ratio( (numerator % denominator), 1 ).
         *
         * @method Ratio.prototype.mod
         * @chainable
         * @return {Ratio}
         * @example
        Ratio(3,10).mod().toString() == &quot;3&quot;
         **&#x2F;
        mod : function () {
            return this.clone(this.numerator % this.denominator, 1);
        },
        &#x2F;**
         * Returns a new instance of the Ratio with the sign toggled.
         *
         * @method Ratio.prototype.negate
         * @chainable
         * @return {Ratio}
         * @example
        Ratio(1,2).negate().toString() == &quot;-1&#x2F;2&quot;
         **&#x2F;
        negate : function () {
            return this.clone(-this.numerator);
        },
        &#x2F;**
         * Determines if the current Ratio is a proper fraction.
         *
         * @method Ratio.prototype.isProper
         * @return {Boolean}
         * @example
        Ratio(12,3).isProper() == false;
         **&#x2F;
        isProper : function () {
            return Math.abs(this.numerator) &lt; this.denominator;
        },
        &#x2F;**
         * Determines the value of x. Solves the following equations.&lt;br&#x2F;&gt;
         * 1. &#x60;( a&#x2F;b = x&#x2F;n )&#x60; or
         * 2. &#x60;( a&#x2F;b = n&#x2F;x )&#x60; &lt;br&#x2F;&gt;
         * Where a, b are the numerator and denominator respectively of the current Ratio.&lt;br&#x2F;&gt;
         * Note: Returns null if the the string can&#x27;t be split into exactly 2 elements.
         *
         * @method Ratio.prototype.findX
         * @chainable
         * @return {Ratio}
         * @example
        Ratio(1,4).findX(&quot;x&#x2F;20&quot;) == 5;
         **&#x2F;
        findX : function (str) {
            var arr = String(str).split(&quot;&#x2F;&quot;);
            if (arr.length !== 2) {
                return null;
            }
            return (isNaN(arr[0]) ? new Ratio(arr[1]).multiply(this) : new Ratio(arr[0]).divide(this));
        },
        &#x2F;**
         * Switches the numerator and denominator positions.
         *
         * @method Ratio.prototype.reciprocal
         * @chainable
         * @return {Ratio}
         * @example
        Ratio(1,2).reciprocal().toString() == &quot;2&#x2F;1&quot;;
         **&#x2F;
        reciprocal : function () {
            return this.clone(this.denominator, this.numerator);
        },
        &#x2F;**
         * From the Ratio instance, approxiates the value to a new fraction with a provided denominator.
         * In otherwords, this method helps you find out what fraction with a given denominator will best
         * represent the current numeric value of the Ratio.
         * Operates on a arbitary amount of arguments and returns the Ratio with the closest match among the quantities.
         * Therefore, an approximated quantity is returned if the absolute value of the difference between the approximated quantity and actual value is
         * smaller than the error rate.
         *
         * @method Ratio.prototype.toQuantityOf
         * @chainable
         * @param {Number, ...} base
         * @return {Ratio}
         * @example
        Ratio(27,100).toQuantityOf(3).toString() == &quot;1&#x2F;3&quot;;
        Ratio(1,2).toQuantityOf(2,3,4).toString() === &quot;1&#x2F;2&quot;;
         **&#x2F;
        toQuantityOf : function () {
            var val = this.valueOf(), x, diff, i, prevDiff = Infinity, len = arguments.length;
            for (i = 0; i &lt; len; i += 1) {
                diff = Math.abs( (Math.round(val * arguments[i])&#x2F;arguments[i]) - val);
                if ( diff &lt; prevDiff ) {
                    x = arguments[i];
                    prevDiff = diff;
                }
            }
            return this.clone(Math.round(val * x), x);
        },
        &#x2F;**
         * Returns a new Ratio from the floor of the current Ratio instance.
         *
         * @method Ratio.prototype.floor 
         * @chainable
         * @return {Ratio}
         * @example
        Ratio.parse(4.2).floor().toString() === &quot;4&#x2F;1&quot;
         *&#x2F;
        floor :  function () {
            return this.clone(Math.floor(this.valueOf()), 1);
        },
        &#x2F;**
         * Returns a new Ratio from the ceil of the current Ratio instance.
         *
         * @method Ratio.prototype.ceil
         * @chainable
         * @return {Ratio}
         * @example
        Ratio.parse(4.2).ceil().toString() === &quot;5&#x2F;1&quot;
         *&#x2F;
        ceil : function () {
            return this.clone(Math.ceil(this.valueOf()), 1);
        },
        &#x2F;**
         * Returns a new Ratio by removing the integer part of the current instance.
         * In otherwords, returns the decimal portion as a fraction.
         *
         * @method Ratio.prototype.makeProper
         * @chainable
         * @return {Ratio}
         * @example
        Ratio.parse(4.2).makeProper().toString() === &quot;2&#x2F;100&quot;
         *&#x2F;
        makeProper : function () {
            return this.clone(this.numerator % this.denominator, this.denominator);
        }
    };
    return Ratio;
}
    ());
&#x2F;&#x2F; Adds npm support
if (typeof exports !== &#x27;undefined&#x27;) {
    if (typeof module !== &#x27;undefined&#x27; &amp;&amp; module.exports) {
        exports = module.exports = Ratio;
    }
    exports.Ratio = Ratio;
}

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
